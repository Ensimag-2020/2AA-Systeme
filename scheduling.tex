\documentclass[11pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\usepackage[a4paper, left=2cm, right=2cm, top=3.5cm, bottom=3.5cm]{geometry}
\usepackage[french]{babel}

% Paragraph spacing
\setlength{\parskip}{1em}

% Fancy headers
\usepackage{fancyhdr}

% Captions for subfigures
\usepackage{subcaption}


% Code highlighting
\usepackage{minted}

% Footnote inside a caption
\usepackage{fnpos}
\usepackage{ftnxtra}

% Colored text, provides \textcolor{color}{text}
\usepackage{xcolor}

% Maths
\usepackage{amsmath}
\usepackage{amssymb}

% Todo notes
\usepackage{todonotes}

% Table of contents for bibliography
\usepackage[nottoc]{tocbibind}

% Inline monospace font
\def\code#1{\texttt{#1}}

% Figures
\usepackage{graphicx}

% Draw figures
\usepackage{tikz}

% Code listing
\usepackage{listings}

% Tikz node rotation
\usetikzlibrary{positioning}

% Turing machine
\usetikzlibrary{chains,fit,shapes}

% Usage: \rotnode[options]{rotation}{text}
\newcommand\rotnode[3][]{%
\node [#1, opacity=0.0] (tmp) {#3};
\node [draw, rotate around={#2:(tmp.center)}] at (tmp) {#3};
}

% remove extra space
\newcommand{\squeezeup}{\vspace{-4.5cm}}

% Clickable links
\usepackage{hyperref}
% Table of contents depth
\setcounter{tocdepth}{2}

% Inline code
\usepackage{listings}
\usepackage{color}

\title{Systèmes d'exploitation - Ordonnancement/Scheduling}

\author{Othmane AJDOR}
\date{2018-2019}

\begin{document}
\maketitle

\pagebreak
\tableofcontents
\pagebreak

\section{Fondamentaux}
\subsection{Qui, où, quoi ?}
Dnas un ordinateur, on réalise de nombreuses opérations en parallèle où le chef d'orchestre est l'OS. C'est lui qui va décider de l'unité de calcul/stockage, de la date d'execution et qui va receuillir le résultat associé à l'operation.\\
On retrouvera dans l'OS plusieurs chefs d'orchestres (ordonnanceurs), notamment celui des processus/threads.

On se confronté à plusieurs problèmes:
\begin{itemize}
    \item Connaitre le futur est difficile, on doit donc prendre des décisions à la volée avec une information partielle.
    \item Structure de données centrale: liste des tâches \underline{prêtes}.
    \item Algorithme de listes \textbf{[Graham, 66, 69, 73]} => lorsqu'une ressource est disponible, y mettre immediatement une tâche prête en prenant la plus prioritaire de la liste. Les taches dans la liste ne sont pas forcement toutes prêtes, on va donc preferer prendre une moins prioritaire et prête qu'une plus prioritaire mais pas prête.
\end{itemize}

\subsection{Complexité et analyses}
Les problèmes d'ordre sont NP complets sauf les triviaux (1 processeur, Cmax), (2 processurs, Cmax) <- NP Complet.

\subsubsection{Algorithme de liste}
\subsubsection{Approximation duale [Schmoys, Hochbaum]}

\subsubsection{Algorithme de liste et tâches [parallèle | avec precedence]}

\subsubsection{Taches paralleles indépendantes}


\pagebreak

\section{Implantations}
\subsection{Disques}
\subsubsection{Algorithme d'ordonnancement: ascenseur}
\begin{itemize}
    \item la tete fait des va et vient
    \item les acces qui sont sous la tete
\end{itemize}

\subsection{SSD}
Agglomeration des acces pour faire des acces plus gros\\
=> systemes de fichiers qui rend les acces "locaux" (ext4, NTFS, HFS+ fonctionnent en ko).

Les SSD fonctionnent en SuperBlock (Mo), on fait un reset à 0 du bloc et on inscrit bit à bit tous les bits qu'il faut passer de 0 à 1. Ce qui veut dire que sur un SSD, on fait un reset du SuperBlock pour ecrire quelques ko (no bueno).

\subsection{Reseaux}
Les reseaux envoient des paquets, lequel il faut envoyer en premier et quand ?\\
Il existe sur Linux un script appelé \textbf{wonder shaper} qui permet de limiter la bande passante d'un ou de plusieurs network adapters en utilisant iproute.

\subsection{Processus/Thread}
\subsubsection{Linux 1.0}
\begin{itemize}
    \item liste unique de tâches prêtes
    \item elle est triée par priorité (fo de priorité goodness)
\end{itemize}

C'est plus simple à utiliser et à régler.\\
Son défaut, le mutex et la manipulation/insertion de la liste, il faut la garder triée pour que ça soit en O(n).

Les ordonnanceurs en O(1) utilisent des liste\textbf{s} par priorité.\\
\begin{figure}
    \centering
    % \includegraphics{}
\end{figure}
Quand la liste "crédits" est vide:
\begin{itemize}
    \item on re-crédite les expirés (en fo de leur priorité)
    \item on inverse les deux ensembles de listes
\end{itemize}
C'est simple à utiliser mais difficle à régler ou calibrer la fonction de crédits qui dit quand est ce qu'on passe.

Les ordonnanceur en O(log(n)) (CFS) utilisent une "liste" (Red-black tree, arbre binaire bien balancé) de priorité, avec une fo de priorité.

\subsection{Multi-Coeurs/Processeurs}
Contention du \underline{\textbf{lock}} protegeant la "liste" => plusieurs listes (1 par coeur/processeur) => pas de lock.\\
Le défaut c'est que maintenant on dispose d'une liste par proc/coeur, ce qui veut dire que certains coeurs peuvent rester sans activité, il faut donc equilibrer les listes.

Vol de travail => un voleur (inoccupé) va choisir (random) une victime et lui prendre des tâches.\\
Une victime c'est bien, deux c'est mieux (c'est le prof qui l'a dit), ça permet d'equilibrer rapidement.


Daemon pour équilibrer. De temps en temps, vole les riches pour donner aux pauvres.\\
Ca coute un peu de temps en temps


\section{Passage à l'echelle}

\end{document}